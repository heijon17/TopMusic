# 1615 PG5600 1 EKS1 2019 HÃ˜ST
Candidatenr. 5039
---
### Overview
* The app has three tab-pages and a detail-view page. 
* The main page has a CollectionVeiw and uses the WebAPIService to fetch top50 content from the web API.
* The Search-page is similar to the main page, but uses the WebAPIService to fetch content based on the SearchBar-string.
* Favourites display favourites stored in CoreData, and lets you remove or reorder them. Also shows recommended artists based on favourite tracks.
* Pressing any item (Album, Track, Favourites) opens the detail-view-page with the selcted items album-info.
* Pressing any track in the detail-view-page will prompt to add track to favourites.
* The App has been tested to run on several screen-sizes: iPhone 8 and iPhone 11 Pro Max in simulator, and iPhone X as device, however iPad screen sizes are not tested and might not be supported. 
* I have tried to focus on usability when developing the app, and for all the actions a user does, some kind of feedback is presented. Example: If the user search for an album and nothing is found, an alert-message is shown. When a track is tapped, confirmation-box asks if user wants to add that track to favourites, and an alert-message shows if it has been added.
---
### Services
* WebAPIService
This service-class uses the Alamofire framework to fetch JSON data from different REST APIs. I chose to use Alamofire instead of NSURLSession since it's easy to use and makes the code cleaner and more readable. The service-class is not a generic class and I made it to work only with this project. Each function in this service will request a JSON response which in turn is decoded into a data-model object and returned to the function-caller.  
* CoreDataService
This service-class is used to get , remove, add or update the order of favourites in the CoreData framework. I chose to use CoreData as the persistent container because it's fast and I wanted to learn how to implement CoreData in an iOS application. I could also store this data on disc as JSON object, but this would be slower. I chose to store all attributes for a track in the CoreData entity so no web-requests are needed for each track to get the info.
* Utils
This is a small util-class with one function: conver milliseconds to a time-format used for displaying track duration.
---
### Models
These are the data-models used when decoding JSON data, and with CoreData. The two CoreData classes are autogenerated by Xcode. The Loadable protocol is used for inheritance to make code better and less redundant. Each Model-class for JSON objects has the Decodable protocol implementation to make it easy for the WebAPIService to decode JSON-data into objects.

